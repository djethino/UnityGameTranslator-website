<?php

namespace App\Http\Controllers;

use App\Models\AnalyticsEvent;
use App\Models\Game;
use App\Models\Translation;
use Illuminate\Http\Request;
use Illuminate\Support\Facades\Storage;

class TranslationController extends Controller
{
    public function create()
    {
        return view('translations.create');
    }

    public function store(Request $request)
    {
        $languages = config('languages');

        $request->validate([
            'game_id' => 'nullable|exists:games,id',
            'game_name' => 'required_without:game_id|string|max:255',
            'source_language' => ['required', 'string', 'in:' . implode(',', $languages)],
            'target_language' => ['required', 'string', 'in:' . implode(',', $languages)],
            'status' => 'required|in:in_progress,complete',
            'type' => 'required|in:ai,human,ai_corrected',
            'notes' => 'nullable|string|max:1000',
            'file' => 'required|file|mimes:json|max:10240', // 10MB max
            'parent_id' => 'nullable|exists:translations,id',
            'game_source' => 'required_without:game_id|string|in:igdb,rawg',
            'game_external_id' => 'required_without:game_id|integer',
            'game_image_url' => 'nullable|url|max:500',
        ]);

        // Find or create game based on API data or existing game_id
        $game = $this->findOrCreateGame($request);

        // Parse JSON to count lines and extract UUID
        $content = file_get_contents($request->file('file')->getRealPath());

        // Limit JSON depth to 2 (must be flat structure)
        $json = json_decode($content, true, 2);

        if (json_last_error() !== JSON_ERROR_NONE) {
            return back()->withErrors(['file' => 'Invalid JSON file: ' . json_last_error_msg()]);
        }

        if (!is_array($json)) {
            return back()->withErrors(['file' => 'Invalid JSON file.']);
        }

        // UUID is required (generated by Unity mod)
        if (!isset($json['_uuid']) || !is_string($json['_uuid'])) {
            return back()->withErrors(['file' => 'Invalid translation file: missing _uuid. This file was not generated by the UnityGameTranslator mod.']);
        }

        // Validate structure: must be flat dictionary of strings only
        foreach ($json as $key => $value) {
            if (!is_string($key) || !is_string($value)) {
                return back()->withErrors(['file' => 'Invalid translation format: must be a flat dictionary with string keys and values.']);
            }
        }

        // Extract UUID from file
        $fileUuid = $json['_uuid'];

        // Count lines (exclude _uuid key)
        $lineCount = count(array_filter(array_keys($json), fn($k) => $k !== '_uuid'));

        // Check if this UUID already exists (auto-detect fork only if different user)
        $parentId = $request->parent_id;
        if ($fileUuid && !$parentId) {
            $originalTranslation = Translation::where('file_uuid', $fileUuid)
                ->orderBy('created_at', 'asc')
                ->first();

            // Only set parent_id if it's a different user (fork)
            // Same user = update (no parent_id)
            if ($originalTranslation && (int) $originalTranslation->user_id !== (int) auth()->id()) {
                $parentId = $originalTranslation->id;
            }
        }

        // Store file
        $path = $request->file('file')->store('translations', 'public');

        // Create translation
        $translation = Translation::create([
            'game_id' => $game->id,
            'user_id' => auth()->id(),
            'parent_id' => $parentId,
            'source_language' => $request->source_language,
            'target_language' => $request->target_language,
            'line_count' => $lineCount,
            'status' => $request->status,
            'type' => $request->type,
            'notes' => $request->notes,
            'file_path' => $path,
            'file_uuid' => $fileUuid,
        ]);

        return redirect()->route('games.show', $game)
            ->with('success', 'Translation uploaded successfully!');
    }

    public function download(Translation $translation)
    {
        $translation->incrementDownloads();

        // Track download for analytics
        try {
            $request = request();
            $userAgent = $request->userAgent() ?? '';
            $ip = $request->ip() ?? '0.0.0.0';

            AnalyticsEvent::create([
                'route' => 'translations.download',
                'game_id' => $translation->game_id,
                'country' => null, // Not tracking country for downloads
                'referrer_domain' => AnalyticsEvent::extractReferrerDomain($request->header('Referer')),
                'device' => AnalyticsEvent::detectDevice($userAgent),
                'browser' => AnalyticsEvent::detectBrowser($userAgent),
                'visitor_hash' => AnalyticsEvent::generateVisitorHash($ip, $userAgent, now()->toDateString()),
                'created_at' => now(),
            ]);
        } catch (\Exception $e) {
            // Silently fail - don't break downloads if analytics fails
            report($e);
        }

        return Storage::disk('public')->download(
            $translation->file_path,
            'translations.json'
        );
    }

    /**
     * Check if a UUID exists and return translation info for auto-fill
     */
    public function checkUuid(Request $request)
    {
        $uuid = $request->get('uuid');

        if (!$uuid) {
            return response()->json(['exists' => false]);
        }

        // Find the original translation with this UUID (first uploaded)
        $translation = Translation::with(['game', 'user'])
            ->where('file_uuid', $uuid)
            ->orderBy('created_at', 'asc')
            ->first();

        if (!$translation) {
            return response()->json(['exists' => false]);
        }

        // Determine if this is an update (same user) or fork (different user)
        $isOwnTranslation = (int) $translation->user_id === (int) auth()->id();

        return response()->json([
            'exists' => true,
            'type' => $isOwnTranslation ? 'update' : 'fork',
            'original_id' => $translation->id,
            'game' => [
                'id' => $translation->game->id,
                'name' => $translation->game->name,
                'image_url' => $translation->game->image_url,
                'igdb_id' => $translation->game->igdb_id,
                'rawg_id' => $translation->game->rawg_id,
            ],
            'source_language' => $translation->source_language,
            'target_language' => $translation->target_language,
            'uploader' => $translation->user->name,
        ]);
    }

    public function myTranslations()
    {
        $translations = auth()->user()->translations()
            ->with(['game', 'forks'])
            ->orderBy('created_at', 'desc')
            ->get();

        return view('translations.mine', compact('translations'));
    }

    public function destroy(Translation $translation)
    {
        if ($translation->user_id !== auth()->id()) {
            abort(403);
        }

        // Delete file
        Storage::disk('public')->delete($translation->file_path);

        // Delete translation (forks will have parent_id set to null via onDelete)
        $translation->delete();

        return redirect()->route('translations.mine')
            ->with('success', 'Translation deleted successfully!');
    }

    /**
     * Find or create a game based on existing game_id or external API data
     */
    private function findOrCreateGame(Request $request): Game
    {
        // If we have a direct game_id (from UUID auto-detection), use it
        if ($request->filled('game_id')) {
            return Game::findOrFail($request->input('game_id'));
        }

        // Otherwise, we must have external API data
        $source = $request->input('game_source');
        $externalId = $request->input('game_external_id');
        $imageUrl = $request->input('game_image_url');
        $name = $request->input('game_name');

        $idField = $source === 'igdb' ? 'igdb_id' : 'rawg_id';

        // Try to find existing game by external ID
        $game = Game::where($idField, $externalId)->first();

        if ($game) {
            // Update image if we have a new one
            if ($imageUrl && !$game->image_url) {
                $game->update(['image_url' => $imageUrl]);
            }
            return $game;
        }

        // Create new game with external ID
        return Game::create([
            'name' => $name,
            $idField => $externalId,
            'image_url' => $imageUrl,
        ]);
    }
}
